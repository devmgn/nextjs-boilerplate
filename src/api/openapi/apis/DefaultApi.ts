/* tslint:disable */
/* eslint-disable */
/**
 * PokéAPI
 * All the Pokémon data you\'ll ever need in one place, easily accessible through a modern free open-source RESTful API.  ## What is this?  This is a full RESTful API linked to an extensive database detailing everything about the Pokémon main game series.  We\'ve covered everything from Pokémon to Berry Flavors.  ## Where do I start?  We have awesome [documentation](https://pokeapi.co/docs/v2) on how to use this API. It takes minutes to get started.  This API will always be publicly available and will never require any extensive setup process to consume.  Created by [**Paul Hallett**(]https://github.com/phalt) and other [**PokéAPI contributors***](https://github.com/PokeAPI/pokeapi#contributing) around the world. Pokémon and Pokémon character names are trademarks of Nintendo.     
 *
 * The version of the OpenAPI document: 2.7.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AbilityDetail,
  BerryDetail,
  BerryFirmnessDetail,
  BerryFlavorDetail,
  CharacteristicDetail,
  ContestEffectDetail,
  ContestTypeDetail,
  EggGroupDetail,
  EncounterConditionDetail,
  EncounterConditionValueDetail,
  EncounterMethodDetail,
  EvolutionChainDetail,
  EvolutionTriggerDetail,
  GenderDetail,
  GenerationDetail,
  GrowthRateDetail,
  ItemAttributeDetail,
  ItemCategoryDetail,
  ItemDetail,
  ItemFlingEffectDetail,
  ItemPocketDetail,
  LanguageDetail,
  LocationAreaDetail,
  LocationDetail,
  MachineDetail,
  MoveBattleStyleDetail,
  MoveDamageClassDetail,
  MoveDetail,
  MoveLearnMethodDetail,
  MoveMetaAilmentDetail,
  MoveMetaCategoryDetail,
  MoveTargetDetail,
  NatureDetail,
  PaginatedAbilitySummaryList,
  PaginatedBerryFirmnessSummaryList,
  PaginatedBerryFlavorSummaryList,
  PaginatedBerrySummaryList,
  PaginatedCharacteristicSummaryList,
  PaginatedContestEffectSummaryList,
  PaginatedContestTypeSummaryList,
  PaginatedEggGroupSummaryList,
  PaginatedEncounterConditionSummaryList,
  PaginatedEncounterConditionValueSummaryList,
  PaginatedEncounterMethodSummaryList,
  PaginatedEvolutionChainSummaryList,
  PaginatedEvolutionTriggerSummaryList,
  PaginatedGenderSummaryList,
  PaginatedGenerationSummaryList,
  PaginatedGrowthRateSummaryList,
  PaginatedItemAttributeSummaryList,
  PaginatedItemCategorySummaryList,
  PaginatedItemFlingEffectSummaryList,
  PaginatedItemPocketSummaryList,
  PaginatedItemSummaryList,
  PaginatedLanguageSummaryList,
  PaginatedLocationAreaSummaryList,
  PaginatedLocationSummaryList,
  PaginatedMachineSummaryList,
  PaginatedMoveBattleStyleSummaryList,
  PaginatedMoveDamageClassSummaryList,
  PaginatedMoveLearnMethodSummaryList,
  PaginatedMoveMetaAilmentSummaryList,
  PaginatedMoveMetaCategorySummaryList,
  PaginatedMoveSummaryList,
  PaginatedMoveTargetSummaryList,
  PaginatedNatureSummaryList,
  PaginatedPalParkAreaSummaryList,
  PaginatedPokeathlonStatSummaryList,
  PaginatedPokedexSummaryList,
  PaginatedPokemonColorSummaryList,
  PaginatedPokemonFormSummaryList,
  PaginatedPokemonHabitatSummaryList,
  PaginatedPokemonShapeSummaryList,
  PaginatedPokemonSpeciesSummaryList,
  PaginatedPokemonSummaryList,
  PaginatedRegionSummaryList,
  PaginatedStatSummaryList,
  PaginatedSuperContestEffectSummaryList,
  PaginatedTypeSummaryList,
  PaginatedVersionGroupSummaryList,
  PaginatedVersionSummaryList,
  PalParkAreaDetail,
  PokeathlonStatDetail,
  PokedexDetail,
  PokemonColorDetail,
  PokemonDetail,
  PokemonEncountersRetrieve200ResponseInner,
  PokemonFormDetail,
  PokemonHabitatDetail,
  PokemonShapeDetail,
  PokemonSpeciesDetail,
  RegionDetail,
  StatDetail,
  SuperContestEffectDetail,
  TypeDetail,
  VersionDetail,
  VersionGroupDetail,
} from '../models/index';
import {
    AbilityDetailFromJSON,
    AbilityDetailToJSON,
    BerryDetailFromJSON,
    BerryDetailToJSON,
    BerryFirmnessDetailFromJSON,
    BerryFirmnessDetailToJSON,
    BerryFlavorDetailFromJSON,
    BerryFlavorDetailToJSON,
    CharacteristicDetailFromJSON,
    CharacteristicDetailToJSON,
    ContestEffectDetailFromJSON,
    ContestEffectDetailToJSON,
    ContestTypeDetailFromJSON,
    ContestTypeDetailToJSON,
    EggGroupDetailFromJSON,
    EggGroupDetailToJSON,
    EncounterConditionDetailFromJSON,
    EncounterConditionDetailToJSON,
    EncounterConditionValueDetailFromJSON,
    EncounterConditionValueDetailToJSON,
    EncounterMethodDetailFromJSON,
    EncounterMethodDetailToJSON,
    EvolutionChainDetailFromJSON,
    EvolutionChainDetailToJSON,
    EvolutionTriggerDetailFromJSON,
    EvolutionTriggerDetailToJSON,
    GenderDetailFromJSON,
    GenderDetailToJSON,
    GenerationDetailFromJSON,
    GenerationDetailToJSON,
    GrowthRateDetailFromJSON,
    GrowthRateDetailToJSON,
    ItemAttributeDetailFromJSON,
    ItemAttributeDetailToJSON,
    ItemCategoryDetailFromJSON,
    ItemCategoryDetailToJSON,
    ItemDetailFromJSON,
    ItemDetailToJSON,
    ItemFlingEffectDetailFromJSON,
    ItemFlingEffectDetailToJSON,
    ItemPocketDetailFromJSON,
    ItemPocketDetailToJSON,
    LanguageDetailFromJSON,
    LanguageDetailToJSON,
    LocationAreaDetailFromJSON,
    LocationAreaDetailToJSON,
    LocationDetailFromJSON,
    LocationDetailToJSON,
    MachineDetailFromJSON,
    MachineDetailToJSON,
    MoveBattleStyleDetailFromJSON,
    MoveBattleStyleDetailToJSON,
    MoveDamageClassDetailFromJSON,
    MoveDamageClassDetailToJSON,
    MoveDetailFromJSON,
    MoveDetailToJSON,
    MoveLearnMethodDetailFromJSON,
    MoveLearnMethodDetailToJSON,
    MoveMetaAilmentDetailFromJSON,
    MoveMetaAilmentDetailToJSON,
    MoveMetaCategoryDetailFromJSON,
    MoveMetaCategoryDetailToJSON,
    MoveTargetDetailFromJSON,
    MoveTargetDetailToJSON,
    NatureDetailFromJSON,
    NatureDetailToJSON,
    PaginatedAbilitySummaryListFromJSON,
    PaginatedAbilitySummaryListToJSON,
    PaginatedBerryFirmnessSummaryListFromJSON,
    PaginatedBerryFirmnessSummaryListToJSON,
    PaginatedBerryFlavorSummaryListFromJSON,
    PaginatedBerryFlavorSummaryListToJSON,
    PaginatedBerrySummaryListFromJSON,
    PaginatedBerrySummaryListToJSON,
    PaginatedCharacteristicSummaryListFromJSON,
    PaginatedCharacteristicSummaryListToJSON,
    PaginatedContestEffectSummaryListFromJSON,
    PaginatedContestEffectSummaryListToJSON,
    PaginatedContestTypeSummaryListFromJSON,
    PaginatedContestTypeSummaryListToJSON,
    PaginatedEggGroupSummaryListFromJSON,
    PaginatedEggGroupSummaryListToJSON,
    PaginatedEncounterConditionSummaryListFromJSON,
    PaginatedEncounterConditionSummaryListToJSON,
    PaginatedEncounterConditionValueSummaryListFromJSON,
    PaginatedEncounterConditionValueSummaryListToJSON,
    PaginatedEncounterMethodSummaryListFromJSON,
    PaginatedEncounterMethodSummaryListToJSON,
    PaginatedEvolutionChainSummaryListFromJSON,
    PaginatedEvolutionChainSummaryListToJSON,
    PaginatedEvolutionTriggerSummaryListFromJSON,
    PaginatedEvolutionTriggerSummaryListToJSON,
    PaginatedGenderSummaryListFromJSON,
    PaginatedGenderSummaryListToJSON,
    PaginatedGenerationSummaryListFromJSON,
    PaginatedGenerationSummaryListToJSON,
    PaginatedGrowthRateSummaryListFromJSON,
    PaginatedGrowthRateSummaryListToJSON,
    PaginatedItemAttributeSummaryListFromJSON,
    PaginatedItemAttributeSummaryListToJSON,
    PaginatedItemCategorySummaryListFromJSON,
    PaginatedItemCategorySummaryListToJSON,
    PaginatedItemFlingEffectSummaryListFromJSON,
    PaginatedItemFlingEffectSummaryListToJSON,
    PaginatedItemPocketSummaryListFromJSON,
    PaginatedItemPocketSummaryListToJSON,
    PaginatedItemSummaryListFromJSON,
    PaginatedItemSummaryListToJSON,
    PaginatedLanguageSummaryListFromJSON,
    PaginatedLanguageSummaryListToJSON,
    PaginatedLocationAreaSummaryListFromJSON,
    PaginatedLocationAreaSummaryListToJSON,
    PaginatedLocationSummaryListFromJSON,
    PaginatedLocationSummaryListToJSON,
    PaginatedMachineSummaryListFromJSON,
    PaginatedMachineSummaryListToJSON,
    PaginatedMoveBattleStyleSummaryListFromJSON,
    PaginatedMoveBattleStyleSummaryListToJSON,
    PaginatedMoveDamageClassSummaryListFromJSON,
    PaginatedMoveDamageClassSummaryListToJSON,
    PaginatedMoveLearnMethodSummaryListFromJSON,
    PaginatedMoveLearnMethodSummaryListToJSON,
    PaginatedMoveMetaAilmentSummaryListFromJSON,
    PaginatedMoveMetaAilmentSummaryListToJSON,
    PaginatedMoveMetaCategorySummaryListFromJSON,
    PaginatedMoveMetaCategorySummaryListToJSON,
    PaginatedMoveSummaryListFromJSON,
    PaginatedMoveSummaryListToJSON,
    PaginatedMoveTargetSummaryListFromJSON,
    PaginatedMoveTargetSummaryListToJSON,
    PaginatedNatureSummaryListFromJSON,
    PaginatedNatureSummaryListToJSON,
    PaginatedPalParkAreaSummaryListFromJSON,
    PaginatedPalParkAreaSummaryListToJSON,
    PaginatedPokeathlonStatSummaryListFromJSON,
    PaginatedPokeathlonStatSummaryListToJSON,
    PaginatedPokedexSummaryListFromJSON,
    PaginatedPokedexSummaryListToJSON,
    PaginatedPokemonColorSummaryListFromJSON,
    PaginatedPokemonColorSummaryListToJSON,
    PaginatedPokemonFormSummaryListFromJSON,
    PaginatedPokemonFormSummaryListToJSON,
    PaginatedPokemonHabitatSummaryListFromJSON,
    PaginatedPokemonHabitatSummaryListToJSON,
    PaginatedPokemonShapeSummaryListFromJSON,
    PaginatedPokemonShapeSummaryListToJSON,
    PaginatedPokemonSpeciesSummaryListFromJSON,
    PaginatedPokemonSpeciesSummaryListToJSON,
    PaginatedPokemonSummaryListFromJSON,
    PaginatedPokemonSummaryListToJSON,
    PaginatedRegionSummaryListFromJSON,
    PaginatedRegionSummaryListToJSON,
    PaginatedStatSummaryListFromJSON,
    PaginatedStatSummaryListToJSON,
    PaginatedSuperContestEffectSummaryListFromJSON,
    PaginatedSuperContestEffectSummaryListToJSON,
    PaginatedTypeSummaryListFromJSON,
    PaginatedTypeSummaryListToJSON,
    PaginatedVersionGroupSummaryListFromJSON,
    PaginatedVersionGroupSummaryListToJSON,
    PaginatedVersionSummaryListFromJSON,
    PaginatedVersionSummaryListToJSON,
    PalParkAreaDetailFromJSON,
    PalParkAreaDetailToJSON,
    PokeathlonStatDetailFromJSON,
    PokeathlonStatDetailToJSON,
    PokedexDetailFromJSON,
    PokedexDetailToJSON,
    PokemonColorDetailFromJSON,
    PokemonColorDetailToJSON,
    PokemonDetailFromJSON,
    PokemonDetailToJSON,
    PokemonEncountersRetrieve200ResponseInnerFromJSON,
    PokemonEncountersRetrieve200ResponseInnerToJSON,
    PokemonFormDetailFromJSON,
    PokemonFormDetailToJSON,
    PokemonHabitatDetailFromJSON,
    PokemonHabitatDetailToJSON,
    PokemonShapeDetailFromJSON,
    PokemonShapeDetailToJSON,
    PokemonSpeciesDetailFromJSON,
    PokemonSpeciesDetailToJSON,
    RegionDetailFromJSON,
    RegionDetailToJSON,
    StatDetailFromJSON,
    StatDetailToJSON,
    SuperContestEffectDetailFromJSON,
    SuperContestEffectDetailToJSON,
    TypeDetailFromJSON,
    TypeDetailToJSON,
    VersionDetailFromJSON,
    VersionDetailToJSON,
    VersionGroupDetailFromJSON,
    VersionGroupDetailToJSON,
} from '../models/index';

export interface AbilityListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface AbilityRetrieveRequest {
    id: string;
}

export interface BerryFirmnessListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface BerryFirmnessRetrieveRequest {
    id: string;
}

export interface BerryFlavorListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface BerryFlavorRetrieveRequest {
    id: string;
}

export interface BerryListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface BerryRetrieveRequest {
    id: string;
}

export interface CharacteristicListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface CharacteristicRetrieveRequest {
    id: string;
}

export interface ContestEffectListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface ContestEffectRetrieveRequest {
    id: string;
}

export interface ContestTypeListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface ContestTypeRetrieveRequest {
    id: string;
}

export interface EggGroupListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface EggGroupRetrieveRequest {
    id: string;
}

export interface EncounterConditionListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface EncounterConditionRetrieveRequest {
    id: string;
}

export interface EncounterConditionValueListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface EncounterConditionValueRetrieveRequest {
    id: string;
}

export interface EncounterMethodListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface EncounterMethodRetrieveRequest {
    id: string;
}

export interface EvolutionChainListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface EvolutionChainRetrieveRequest {
    id: string;
}

export interface EvolutionTriggerListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface EvolutionTriggerRetrieveRequest {
    id: string;
}

export interface GenderListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface GenderRetrieveRequest {
    id: string;
}

export interface GenerationListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface GenerationRetrieveRequest {
    id: string;
}

export interface GrowthRateListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface GrowthRateRetrieveRequest {
    id: string;
}

export interface ItemAttributeListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface ItemAttributeRetrieveRequest {
    id: string;
}

export interface ItemCategoryListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface ItemCategoryRetrieveRequest {
    id: string;
}

export interface ItemFlingEffectListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface ItemFlingEffectRetrieveRequest {
    id: string;
}

export interface ItemListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface ItemPocketListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface ItemPocketRetrieveRequest {
    id: string;
}

export interface ItemRetrieveRequest {
    id: string;
}

export interface LanguageListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface LanguageRetrieveRequest {
    id: string;
}

export interface LocationAreaListRequest {
    limit?: number;
    offset?: number;
}

export interface LocationAreaRetrieveRequest {
    id: number;
}

export interface LocationListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface LocationRetrieveRequest {
    id: string;
}

export interface MachineListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface MachineRetrieveRequest {
    id: string;
}

export interface MoveAilmentListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface MoveAilmentRetrieveRequest {
    id: string;
}

export interface MoveBattleStyleListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface MoveBattleStyleRetrieveRequest {
    id: string;
}

export interface MoveCategoryListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface MoveCategoryRetrieveRequest {
    id: string;
}

export interface MoveDamageClassListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface MoveDamageClassRetrieveRequest {
    id: string;
}

export interface MoveLearnMethodListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface MoveLearnMethodRetrieveRequest {
    id: string;
}

export interface MoveListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface MoveRetrieveRequest {
    id: string;
}

export interface MoveTargetListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface MoveTargetRetrieveRequest {
    id: string;
}

export interface NatureListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface NatureRetrieveRequest {
    id: string;
}

export interface PalParkAreaListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface PalParkAreaRetrieveRequest {
    id: string;
}

export interface PokeathlonStatListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface PokeathlonStatRetrieveRequest {
    id: string;
}

export interface PokedexListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface PokedexRetrieveRequest {
    id: string;
}

export interface PokemonColorListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface PokemonColorRetrieveRequest {
    id: string;
}

export interface PokemonEncountersRetrieveRequest {
    pokemonId: string;
}

export interface PokemonFormListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface PokemonFormRetrieveRequest {
    id: string;
}

export interface PokemonHabitatListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface PokemonHabitatRetrieveRequest {
    id: string;
}

export interface PokemonListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface PokemonRetrieveRequest {
    id: string;
}

export interface PokemonShapeListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface PokemonShapeRetrieveRequest {
    id: string;
}

export interface PokemonSpeciesListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface PokemonSpeciesRetrieveRequest {
    id: string;
}

export interface RegionListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface RegionRetrieveRequest {
    id: string;
}

export interface StatListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface StatRetrieveRequest {
    id: string;
}

export interface SuperContestEffectListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface SuperContestEffectRetrieveRequest {
    id: string;
}

export interface TypeListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface TypeRetrieveRequest {
    id: string;
}

export interface VersionGroupListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface VersionGroupRetrieveRequest {
    id: string;
}

export interface VersionListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface VersionRetrieveRequest {
    id: string;
}

/**
 * 
 */
export class DefaultApi extends runtime.BaseAPI {

    /**
     * Abilities provide passive effects for Pokémon in battle or in the overworld. Pokémon have multiple possible abilities but can have only one ability at a time. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Ability) for greater detail.
     */
    async abilityListRaw(requestParameters: AbilityListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedAbilitySummaryList>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/ability/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedAbilitySummaryListFromJSON(jsonValue));
    }

    /**
     * Abilities provide passive effects for Pokémon in battle or in the overworld. Pokémon have multiple possible abilities but can have only one ability at a time. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Ability) for greater detail.
     */
    async abilityList(requestParameters: AbilityListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedAbilitySummaryList> {
        const response = await this.abilityListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Abilities provide passive effects for Pokémon in battle or in the overworld. Pokémon have multiple possible abilities but can have only one ability at a time. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Ability) for greater detail.
     */
    async abilityRetrieveRaw(requestParameters: AbilityRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AbilityDetail>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling abilityRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/ability/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AbilityDetailFromJSON(jsonValue));
    }

    /**
     * Abilities provide passive effects for Pokémon in battle or in the overworld. Pokémon have multiple possible abilities but can have only one ability at a time. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Ability) for greater detail.
     */
    async abilityRetrieve(requestParameters: AbilityRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AbilityDetail> {
        const response = await this.abilityRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Berries can be soft or hard. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Category:Berries_by_firmness) for greater detail.
     * List berry firmness
     */
    async berryFirmnessListRaw(requestParameters: BerryFirmnessListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedBerryFirmnessSummaryList>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/berry-firmness/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedBerryFirmnessSummaryListFromJSON(jsonValue));
    }

    /**
     * Berries can be soft or hard. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Category:Berries_by_firmness) for greater detail.
     * List berry firmness
     */
    async berryFirmnessList(requestParameters: BerryFirmnessListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedBerryFirmnessSummaryList> {
        const response = await this.berryFirmnessListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Berries can be soft or hard. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Category:Berries_by_firmness) for greater detail.
     * Get berry by firmness
     */
    async berryFirmnessRetrieveRaw(requestParameters: BerryFirmnessRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BerryFirmnessDetail>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling berryFirmnessRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/berry-firmness/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BerryFirmnessDetailFromJSON(jsonValue));
    }

    /**
     * Berries can be soft or hard. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Category:Berries_by_firmness) for greater detail.
     * Get berry by firmness
     */
    async berryFirmnessRetrieve(requestParameters: BerryFirmnessRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BerryFirmnessDetail> {
        const response = await this.berryFirmnessRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Flavors determine whether a Pokémon will benefit or suffer from eating a berry based on their **nature**. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Flavor) for greater detail.
     * List berry flavors
     */
    async berryFlavorListRaw(requestParameters: BerryFlavorListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedBerryFlavorSummaryList>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/berry-flavor/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedBerryFlavorSummaryListFromJSON(jsonValue));
    }

    /**
     * Flavors determine whether a Pokémon will benefit or suffer from eating a berry based on their **nature**. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Flavor) for greater detail.
     * List berry flavors
     */
    async berryFlavorList(requestParameters: BerryFlavorListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedBerryFlavorSummaryList> {
        const response = await this.berryFlavorListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Flavors determine whether a Pokémon will benefit or suffer from eating a berry based on their **nature**. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Flavor) for greater detail.
     * Get berries by flavor
     */
    async berryFlavorRetrieveRaw(requestParameters: BerryFlavorRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BerryFlavorDetail>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling berryFlavorRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/berry-flavor/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BerryFlavorDetailFromJSON(jsonValue));
    }

    /**
     * Flavors determine whether a Pokémon will benefit or suffer from eating a berry based on their **nature**. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Flavor) for greater detail.
     * Get berries by flavor
     */
    async berryFlavorRetrieve(requestParameters: BerryFlavorRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BerryFlavorDetail> {
        const response = await this.berryFlavorRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Berries are small fruits that can provide HP and status condition restoration, stat enhancement, and even damage negation when eaten by Pokémon. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Berry) for greater detail.
     * List berries
     */
    async berryListRaw(requestParameters: BerryListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedBerrySummaryList>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/berry/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedBerrySummaryListFromJSON(jsonValue));
    }

    /**
     * Berries are small fruits that can provide HP and status condition restoration, stat enhancement, and even damage negation when eaten by Pokémon. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Berry) for greater detail.
     * List berries
     */
    async berryList(requestParameters: BerryListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedBerrySummaryList> {
        const response = await this.berryListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Berries are small fruits that can provide HP and status condition restoration, stat enhancement, and even damage negation when eaten by Pokémon. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Berry) for greater detail.
     * Get a berry
     */
    async berryRetrieveRaw(requestParameters: BerryRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BerryDetail>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling berryRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/berry/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BerryDetailFromJSON(jsonValue));
    }

    /**
     * Berries are small fruits that can provide HP and status condition restoration, stat enhancement, and even damage negation when eaten by Pokémon. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Berry) for greater detail.
     * Get a berry
     */
    async berryRetrieve(requestParameters: BerryRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BerryDetail> {
        const response = await this.berryRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Characteristics indicate which stat contains a Pokémon\'s highest IV. A Pokémon\'s Characteristic is determined by the remainder of its highest IV divided by 5 (gene_modulo). Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Characteristic) for greater detail.
     * List charecterictics
     */
    async characteristicListRaw(requestParameters: CharacteristicListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedCharacteristicSummaryList>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/characteristic/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedCharacteristicSummaryListFromJSON(jsonValue));
    }

    /**
     * Characteristics indicate which stat contains a Pokémon\'s highest IV. A Pokémon\'s Characteristic is determined by the remainder of its highest IV divided by 5 (gene_modulo). Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Characteristic) for greater detail.
     * List charecterictics
     */
    async characteristicList(requestParameters: CharacteristicListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedCharacteristicSummaryList> {
        const response = await this.characteristicListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Characteristics indicate which stat contains a Pokémon\'s highest IV. A Pokémon\'s Characteristic is determined by the remainder of its highest IV divided by 5 (gene_modulo). Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Characteristic) for greater detail.
     * Get characteristic
     */
    async characteristicRetrieveRaw(requestParameters: CharacteristicRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CharacteristicDetail>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling characteristicRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/characteristic/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CharacteristicDetailFromJSON(jsonValue));
    }

    /**
     * Characteristics indicate which stat contains a Pokémon\'s highest IV. A Pokémon\'s Characteristic is determined by the remainder of its highest IV divided by 5 (gene_modulo). Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Characteristic) for greater detail.
     * Get characteristic
     */
    async characteristicRetrieve(requestParameters: CharacteristicRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CharacteristicDetail> {
        const response = await this.characteristicRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Contest effects refer to the effects of moves when used in contests.
     * List contest effects
     */
    async contestEffectListRaw(requestParameters: ContestEffectListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedContestEffectSummaryList>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/contest-effect/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedContestEffectSummaryListFromJSON(jsonValue));
    }

    /**
     * Contest effects refer to the effects of moves when used in contests.
     * List contest effects
     */
    async contestEffectList(requestParameters: ContestEffectListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedContestEffectSummaryList> {
        const response = await this.contestEffectListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Contest effects refer to the effects of moves when used in contests.
     * Get contest effect
     */
    async contestEffectRetrieveRaw(requestParameters: ContestEffectRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ContestEffectDetail>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling contestEffectRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/contest-effect/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ContestEffectDetailFromJSON(jsonValue));
    }

    /**
     * Contest effects refer to the effects of moves when used in contests.
     * Get contest effect
     */
    async contestEffectRetrieve(requestParameters: ContestEffectRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ContestEffectDetail> {
        const response = await this.contestEffectRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Contest types are categories judges used to weigh a Pokémon\'s condition in Pokémon contests. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Contest_condition) for greater detail.
     * List contest types
     */
    async contestTypeListRaw(requestParameters: ContestTypeListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedContestTypeSummaryList>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/contest-type/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedContestTypeSummaryListFromJSON(jsonValue));
    }

    /**
     * Contest types are categories judges used to weigh a Pokémon\'s condition in Pokémon contests. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Contest_condition) for greater detail.
     * List contest types
     */
    async contestTypeList(requestParameters: ContestTypeListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedContestTypeSummaryList> {
        const response = await this.contestTypeListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Contest types are categories judges used to weigh a Pokémon\'s condition in Pokémon contests. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Contest_condition) for greater detail.
     * Get contest type
     */
    async contestTypeRetrieveRaw(requestParameters: ContestTypeRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ContestTypeDetail>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling contestTypeRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/contest-type/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ContestTypeDetailFromJSON(jsonValue));
    }

    /**
     * Contest types are categories judges used to weigh a Pokémon\'s condition in Pokémon contests. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Contest_condition) for greater detail.
     * Get contest type
     */
    async contestTypeRetrieve(requestParameters: ContestTypeRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ContestTypeDetail> {
        const response = await this.contestTypeRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Egg Groups are categories which determine which Pokémon are able to interbreed. Pokémon may belong to either one or two Egg Groups. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Egg_Group) for greater detail.
     * List egg groups
     */
    async eggGroupListRaw(requestParameters: EggGroupListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedEggGroupSummaryList>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/egg-group/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedEggGroupSummaryListFromJSON(jsonValue));
    }

    /**
     * Egg Groups are categories which determine which Pokémon are able to interbreed. Pokémon may belong to either one or two Egg Groups. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Egg_Group) for greater detail.
     * List egg groups
     */
    async eggGroupList(requestParameters: EggGroupListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedEggGroupSummaryList> {
        const response = await this.eggGroupListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Egg Groups are categories which determine which Pokémon are able to interbreed. Pokémon may belong to either one or two Egg Groups. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Egg_Group) for greater detail.
     * Get egg group
     */
    async eggGroupRetrieveRaw(requestParameters: EggGroupRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EggGroupDetail>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling eggGroupRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/egg-group/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EggGroupDetailFromJSON(jsonValue));
    }

    /**
     * Egg Groups are categories which determine which Pokémon are able to interbreed. Pokémon may belong to either one or two Egg Groups. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Egg_Group) for greater detail.
     * Get egg group
     */
    async eggGroupRetrieve(requestParameters: EggGroupRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EggGroupDetail> {
        const response = await this.eggGroupRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Conditions which affect what pokemon might appear in the wild, e.g., day or night.
     * List encounter conditions
     */
    async encounterConditionListRaw(requestParameters: EncounterConditionListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedEncounterConditionSummaryList>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/encounter-condition/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedEncounterConditionSummaryListFromJSON(jsonValue));
    }

    /**
     * Conditions which affect what pokemon might appear in the wild, e.g., day or night.
     * List encounter conditions
     */
    async encounterConditionList(requestParameters: EncounterConditionListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedEncounterConditionSummaryList> {
        const response = await this.encounterConditionListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Conditions which affect what pokemon might appear in the wild, e.g., day or night.
     * Get encounter condition
     */
    async encounterConditionRetrieveRaw(requestParameters: EncounterConditionRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EncounterConditionDetail>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling encounterConditionRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/encounter-condition/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EncounterConditionDetailFromJSON(jsonValue));
    }

    /**
     * Conditions which affect what pokemon might appear in the wild, e.g., day or night.
     * Get encounter condition
     */
    async encounterConditionRetrieve(requestParameters: EncounterConditionRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EncounterConditionDetail> {
        const response = await this.encounterConditionRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Encounter condition values are the various states that an encounter condition can have, i.e., time of day can be either day or night.
     * List encounter condition values
     */
    async encounterConditionValueListRaw(requestParameters: EncounterConditionValueListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedEncounterConditionValueSummaryList>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/encounter-condition-value/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedEncounterConditionValueSummaryListFromJSON(jsonValue));
    }

    /**
     * Encounter condition values are the various states that an encounter condition can have, i.e., time of day can be either day or night.
     * List encounter condition values
     */
    async encounterConditionValueList(requestParameters: EncounterConditionValueListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedEncounterConditionValueSummaryList> {
        const response = await this.encounterConditionValueListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Encounter condition values are the various states that an encounter condition can have, i.e., time of day can be either day or night.
     * Get encounter condition value
     */
    async encounterConditionValueRetrieveRaw(requestParameters: EncounterConditionValueRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EncounterConditionValueDetail>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling encounterConditionValueRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/encounter-condition-value/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EncounterConditionValueDetailFromJSON(jsonValue));
    }

    /**
     * Encounter condition values are the various states that an encounter condition can have, i.e., time of day can be either day or night.
     * Get encounter condition value
     */
    async encounterConditionValueRetrieve(requestParameters: EncounterConditionValueRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EncounterConditionValueDetail> {
        const response = await this.encounterConditionValueRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Methods by which the player might can encounter Pokémon in the wild, e.g., walking in tall grass. Check out Bulbapedia for greater detail.
     * List encounter methods
     */
    async encounterMethodListRaw(requestParameters: EncounterMethodListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedEncounterMethodSummaryList>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/encounter-method/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedEncounterMethodSummaryListFromJSON(jsonValue));
    }

    /**
     * Methods by which the player might can encounter Pokémon in the wild, e.g., walking in tall grass. Check out Bulbapedia for greater detail.
     * List encounter methods
     */
    async encounterMethodList(requestParameters: EncounterMethodListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedEncounterMethodSummaryList> {
        const response = await this.encounterMethodListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Methods by which the player might can encounter Pokémon in the wild, e.g., walking in tall grass. Check out Bulbapedia for greater detail.
     * Get encounter method
     */
    async encounterMethodRetrieveRaw(requestParameters: EncounterMethodRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EncounterMethodDetail>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling encounterMethodRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/encounter-method/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EncounterMethodDetailFromJSON(jsonValue));
    }

    /**
     * Methods by which the player might can encounter Pokémon in the wild, e.g., walking in tall grass. Check out Bulbapedia for greater detail.
     * Get encounter method
     */
    async encounterMethodRetrieve(requestParameters: EncounterMethodRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EncounterMethodDetail> {
        const response = await this.encounterMethodRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Evolution chains are essentially family trees. They start with the lowest stage within a family and detail evolution conditions for each as well as Pokémon they can evolve into up through the hierarchy.
     * List evolution chains
     */
    async evolutionChainListRaw(requestParameters: EvolutionChainListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedEvolutionChainSummaryList>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/evolution-chain/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedEvolutionChainSummaryListFromJSON(jsonValue));
    }

    /**
     * Evolution chains are essentially family trees. They start with the lowest stage within a family and detail evolution conditions for each as well as Pokémon they can evolve into up through the hierarchy.
     * List evolution chains
     */
    async evolutionChainList(requestParameters: EvolutionChainListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedEvolutionChainSummaryList> {
        const response = await this.evolutionChainListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Evolution chains are essentially family trees. They start with the lowest stage within a family and detail evolution conditions for each as well as Pokémon they can evolve into up through the hierarchy.
     * Get evolution chain
     */
    async evolutionChainRetrieveRaw(requestParameters: EvolutionChainRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EvolutionChainDetail>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling evolutionChainRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/evolution-chain/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EvolutionChainDetailFromJSON(jsonValue));
    }

    /**
     * Evolution chains are essentially family trees. They start with the lowest stage within a family and detail evolution conditions for each as well as Pokémon they can evolve into up through the hierarchy.
     * Get evolution chain
     */
    async evolutionChainRetrieve(requestParameters: EvolutionChainRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EvolutionChainDetail> {
        const response = await this.evolutionChainRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Evolution triggers are the events and conditions that cause a Pokémon to evolve. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Methods_of_evolution) for greater detail.
     * List evolution triggers
     */
    async evolutionTriggerListRaw(requestParameters: EvolutionTriggerListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedEvolutionTriggerSummaryList>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/evolution-trigger/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedEvolutionTriggerSummaryListFromJSON(jsonValue));
    }

    /**
     * Evolution triggers are the events and conditions that cause a Pokémon to evolve. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Methods_of_evolution) for greater detail.
     * List evolution triggers
     */
    async evolutionTriggerList(requestParameters: EvolutionTriggerListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedEvolutionTriggerSummaryList> {
        const response = await this.evolutionTriggerListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Evolution triggers are the events and conditions that cause a Pokémon to evolve. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Methods_of_evolution) for greater detail.
     * Get evolution trigger
     */
    async evolutionTriggerRetrieveRaw(requestParameters: EvolutionTriggerRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EvolutionTriggerDetail>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling evolutionTriggerRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/evolution-trigger/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EvolutionTriggerDetailFromJSON(jsonValue));
    }

    /**
     * Evolution triggers are the events and conditions that cause a Pokémon to evolve. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Methods_of_evolution) for greater detail.
     * Get evolution trigger
     */
    async evolutionTriggerRetrieve(requestParameters: EvolutionTriggerRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EvolutionTriggerDetail> {
        const response = await this.evolutionTriggerRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Genders were introduced in Generation II for the purposes of breeding Pokémon but can also result in visual differences or even different evolutionary lines. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Gender) for greater detail.
     * List genders
     */
    async genderListRaw(requestParameters: GenderListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedGenderSummaryList>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/gender/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedGenderSummaryListFromJSON(jsonValue));
    }

    /**
     * Genders were introduced in Generation II for the purposes of breeding Pokémon but can also result in visual differences or even different evolutionary lines. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Gender) for greater detail.
     * List genders
     */
    async genderList(requestParameters: GenderListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedGenderSummaryList> {
        const response = await this.genderListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Genders were introduced in Generation II for the purposes of breeding Pokémon but can also result in visual differences or even different evolutionary lines. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Gender) for greater detail.
     * Get gender
     */
    async genderRetrieveRaw(requestParameters: GenderRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GenderDetail>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling genderRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/gender/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GenderDetailFromJSON(jsonValue));
    }

    /**
     * Genders were introduced in Generation II for the purposes of breeding Pokémon but can also result in visual differences or even different evolutionary lines. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Gender) for greater detail.
     * Get gender
     */
    async genderRetrieve(requestParameters: GenderRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GenderDetail> {
        const response = await this.genderRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * A generation is a grouping of the Pokémon games that separates them based on the Pokémon they include. In each generation, a new set of Pokémon, Moves, Abilities and Types that did not exist in the previous generation are released.
     * List genrations
     */
    async generationListRaw(requestParameters: GenerationListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedGenerationSummaryList>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/generation/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedGenerationSummaryListFromJSON(jsonValue));
    }

    /**
     * A generation is a grouping of the Pokémon games that separates them based on the Pokémon they include. In each generation, a new set of Pokémon, Moves, Abilities and Types that did not exist in the previous generation are released.
     * List genrations
     */
    async generationList(requestParameters: GenerationListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedGenerationSummaryList> {
        const response = await this.generationListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * A generation is a grouping of the Pokémon games that separates them based on the Pokémon they include. In each generation, a new set of Pokémon, Moves, Abilities and Types that did not exist in the previous generation are released.
     * Get genration
     */
    async generationRetrieveRaw(requestParameters: GenerationRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GenerationDetail>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling generationRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/generation/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GenerationDetailFromJSON(jsonValue));
    }

    /**
     * A generation is a grouping of the Pokémon games that separates them based on the Pokémon they include. In each generation, a new set of Pokémon, Moves, Abilities and Types that did not exist in the previous generation are released.
     * Get genration
     */
    async generationRetrieve(requestParameters: GenerationRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GenerationDetail> {
        const response = await this.generationRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Growth rates are the speed with which Pokémon gain levels through experience. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Experience) for greater detail.
     * List growth rates
     */
    async growthRateListRaw(requestParameters: GrowthRateListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedGrowthRateSummaryList>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/growth-rate/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedGrowthRateSummaryListFromJSON(jsonValue));
    }

    /**
     * Growth rates are the speed with which Pokémon gain levels through experience. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Experience) for greater detail.
     * List growth rates
     */
    async growthRateList(requestParameters: GrowthRateListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedGrowthRateSummaryList> {
        const response = await this.growthRateListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Growth rates are the speed with which Pokémon gain levels through experience. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Experience) for greater detail.
     * Get growth rate
     */
    async growthRateRetrieveRaw(requestParameters: GrowthRateRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GrowthRateDetail>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling growthRateRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/growth-rate/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GrowthRateDetailFromJSON(jsonValue));
    }

    /**
     * Growth rates are the speed with which Pokémon gain levels through experience. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Experience) for greater detail.
     * Get growth rate
     */
    async growthRateRetrieve(requestParameters: GrowthRateRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GrowthRateDetail> {
        const response = await this.growthRateRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Item attributes define particular aspects of items, e.g.\"usable in battle\" or \"consumable\".
     * List item attributes
     */
    async itemAttributeListRaw(requestParameters: ItemAttributeListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedItemAttributeSummaryList>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/item-attribute/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedItemAttributeSummaryListFromJSON(jsonValue));
    }

    /**
     * Item attributes define particular aspects of items, e.g.\"usable in battle\" or \"consumable\".
     * List item attributes
     */
    async itemAttributeList(requestParameters: ItemAttributeListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedItemAttributeSummaryList> {
        const response = await this.itemAttributeListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Item attributes define particular aspects of items, e.g.\"usable in battle\" or \"consumable\".
     * Get item attribute
     */
    async itemAttributeRetrieveRaw(requestParameters: ItemAttributeRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ItemAttributeDetail>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling itemAttributeRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/item-attribute/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ItemAttributeDetailFromJSON(jsonValue));
    }

    /**
     * Item attributes define particular aspects of items, e.g.\"usable in battle\" or \"consumable\".
     * Get item attribute
     */
    async itemAttributeRetrieve(requestParameters: ItemAttributeRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ItemAttributeDetail> {
        const response = await this.itemAttributeRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Item categories determine where items will be placed in the players bag.
     * List item categories
     */
    async itemCategoryListRaw(requestParameters: ItemCategoryListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedItemCategorySummaryList>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/item-category/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedItemCategorySummaryListFromJSON(jsonValue));
    }

    /**
     * Item categories determine where items will be placed in the players bag.
     * List item categories
     */
    async itemCategoryList(requestParameters: ItemCategoryListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedItemCategorySummaryList> {
        const response = await this.itemCategoryListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Item categories determine where items will be placed in the players bag.
     * Get item category
     */
    async itemCategoryRetrieveRaw(requestParameters: ItemCategoryRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ItemCategoryDetail>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling itemCategoryRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/item-category/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ItemCategoryDetailFromJSON(jsonValue));
    }

    /**
     * Item categories determine where items will be placed in the players bag.
     * Get item category
     */
    async itemCategoryRetrieve(requestParameters: ItemCategoryRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ItemCategoryDetail> {
        const response = await this.itemCategoryRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * The various effects of the move\"Fling\" when used with different items.
     * List item fling effects
     */
    async itemFlingEffectListRaw(requestParameters: ItemFlingEffectListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedItemFlingEffectSummaryList>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/item-fling-effect/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedItemFlingEffectSummaryListFromJSON(jsonValue));
    }

    /**
     * The various effects of the move\"Fling\" when used with different items.
     * List item fling effects
     */
    async itemFlingEffectList(requestParameters: ItemFlingEffectListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedItemFlingEffectSummaryList> {
        const response = await this.itemFlingEffectListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * The various effects of the move\"Fling\" when used with different items.
     * Get item fling effect
     */
    async itemFlingEffectRetrieveRaw(requestParameters: ItemFlingEffectRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ItemFlingEffectDetail>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling itemFlingEffectRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/item-fling-effect/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ItemFlingEffectDetailFromJSON(jsonValue));
    }

    /**
     * The various effects of the move\"Fling\" when used with different items.
     * Get item fling effect
     */
    async itemFlingEffectRetrieve(requestParameters: ItemFlingEffectRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ItemFlingEffectDetail> {
        const response = await this.itemFlingEffectRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * An item is an object in the games which the player can pick up, keep in their bag, and use in some manner. They have various uses, including healing, powering up, helping catch Pokémon, or to access a new area.
     * List items
     */
    async itemListRaw(requestParameters: ItemListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedItemSummaryList>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/item/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedItemSummaryListFromJSON(jsonValue));
    }

    /**
     * An item is an object in the games which the player can pick up, keep in their bag, and use in some manner. They have various uses, including healing, powering up, helping catch Pokémon, or to access a new area.
     * List items
     */
    async itemList(requestParameters: ItemListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedItemSummaryList> {
        const response = await this.itemListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Pockets within the players bag used for storing items by category.
     * List item pockets
     */
    async itemPocketListRaw(requestParameters: ItemPocketListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedItemPocketSummaryList>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/item-pocket/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedItemPocketSummaryListFromJSON(jsonValue));
    }

    /**
     * Pockets within the players bag used for storing items by category.
     * List item pockets
     */
    async itemPocketList(requestParameters: ItemPocketListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedItemPocketSummaryList> {
        const response = await this.itemPocketListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Pockets within the players bag used for storing items by category.
     * Get item pocket
     */
    async itemPocketRetrieveRaw(requestParameters: ItemPocketRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ItemPocketDetail>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling itemPocketRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/item-pocket/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ItemPocketDetailFromJSON(jsonValue));
    }

    /**
     * Pockets within the players bag used for storing items by category.
     * Get item pocket
     */
    async itemPocketRetrieve(requestParameters: ItemPocketRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ItemPocketDetail> {
        const response = await this.itemPocketRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * An item is an object in the games which the player can pick up, keep in their bag, and use in some manner. They have various uses, including healing, powering up, helping catch Pokémon, or to access a new area.
     * Get item
     */
    async itemRetrieveRaw(requestParameters: ItemRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ItemDetail>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling itemRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/item/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ItemDetailFromJSON(jsonValue));
    }

    /**
     * An item is an object in the games which the player can pick up, keep in their bag, and use in some manner. They have various uses, including healing, powering up, helping catch Pokémon, or to access a new area.
     * Get item
     */
    async itemRetrieve(requestParameters: ItemRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ItemDetail> {
        const response = await this.itemRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Languages for translations of API resource information.
     * List languages
     */
    async languageListRaw(requestParameters: LanguageListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedLanguageSummaryList>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/language/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedLanguageSummaryListFromJSON(jsonValue));
    }

    /**
     * Languages for translations of API resource information.
     * List languages
     */
    async languageList(requestParameters: LanguageListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedLanguageSummaryList> {
        const response = await this.languageListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Languages for translations of API resource information.
     * Get language
     */
    async languageRetrieveRaw(requestParameters: LanguageRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LanguageDetail>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling languageRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/language/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LanguageDetailFromJSON(jsonValue));
    }

    /**
     * Languages for translations of API resource information.
     * Get language
     */
    async languageRetrieve(requestParameters: LanguageRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LanguageDetail> {
        const response = await this.languageRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Location areas are sections of areas, such as floors in a building or cave. Each area has its own set of possible Pokémon encounters.
     * List location areas
     */
    async locationAreaListRaw(requestParameters: LocationAreaListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedLocationAreaSummaryList>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/location-area/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedLocationAreaSummaryListFromJSON(jsonValue));
    }

    /**
     * Location areas are sections of areas, such as floors in a building or cave. Each area has its own set of possible Pokémon encounters.
     * List location areas
     */
    async locationAreaList(requestParameters: LocationAreaListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedLocationAreaSummaryList> {
        const response = await this.locationAreaListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Location areas are sections of areas, such as floors in a building or cave. Each area has its own set of possible Pokémon encounters.
     * Get location area
     */
    async locationAreaRetrieveRaw(requestParameters: LocationAreaRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LocationAreaDetail>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling locationAreaRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/location-area/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LocationAreaDetailFromJSON(jsonValue));
    }

    /**
     * Location areas are sections of areas, such as floors in a building or cave. Each area has its own set of possible Pokémon encounters.
     * Get location area
     */
    async locationAreaRetrieve(requestParameters: LocationAreaRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LocationAreaDetail> {
        const response = await this.locationAreaRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Locations that can be visited within the games. Locations make up sizable portions of regions, like cities or routes.
     * List locations
     */
    async locationListRaw(requestParameters: LocationListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedLocationSummaryList>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/location/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedLocationSummaryListFromJSON(jsonValue));
    }

    /**
     * Locations that can be visited within the games. Locations make up sizable portions of regions, like cities or routes.
     * List locations
     */
    async locationList(requestParameters: LocationListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedLocationSummaryList> {
        const response = await this.locationListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Locations that can be visited within the games. Locations make up sizable portions of regions, like cities or routes.
     * Get location
     */
    async locationRetrieveRaw(requestParameters: LocationRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LocationDetail>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling locationRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/location/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LocationDetailFromJSON(jsonValue));
    }

    /**
     * Locations that can be visited within the games. Locations make up sizable portions of regions, like cities or routes.
     * Get location
     */
    async locationRetrieve(requestParameters: LocationRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LocationDetail> {
        const response = await this.locationRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Machines are the representation of items that teach moves to Pokémon. They vary from version to version, so it is not certain that one specific TM or HM corresponds to a single Machine.
     * List machines
     */
    async machineListRaw(requestParameters: MachineListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedMachineSummaryList>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/machine/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedMachineSummaryListFromJSON(jsonValue));
    }

    /**
     * Machines are the representation of items that teach moves to Pokémon. They vary from version to version, so it is not certain that one specific TM or HM corresponds to a single Machine.
     * List machines
     */
    async machineList(requestParameters: MachineListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedMachineSummaryList> {
        const response = await this.machineListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Machines are the representation of items that teach moves to Pokémon. They vary from version to version, so it is not certain that one specific TM or HM corresponds to a single Machine.
     * Get machine
     */
    async machineRetrieveRaw(requestParameters: MachineRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MachineDetail>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling machineRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/machine/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MachineDetailFromJSON(jsonValue));
    }

    /**
     * Machines are the representation of items that teach moves to Pokémon. They vary from version to version, so it is not certain that one specific TM or HM corresponds to a single Machine.
     * Get machine
     */
    async machineRetrieve(requestParameters: MachineRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MachineDetail> {
        const response = await this.machineRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Move Ailments are status conditions caused by moves used during battle. See [Bulbapedia](https://bulbapedia.bulbagarden.net/wiki/Status_condition) for greater detail.
     * List move meta ailments
     */
    async moveAilmentListRaw(requestParameters: MoveAilmentListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedMoveMetaAilmentSummaryList>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/move-ailment/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedMoveMetaAilmentSummaryListFromJSON(jsonValue));
    }

    /**
     * Move Ailments are status conditions caused by moves used during battle. See [Bulbapedia](https://bulbapedia.bulbagarden.net/wiki/Status_condition) for greater detail.
     * List move meta ailments
     */
    async moveAilmentList(requestParameters: MoveAilmentListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedMoveMetaAilmentSummaryList> {
        const response = await this.moveAilmentListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Move Ailments are status conditions caused by moves used during battle. See [Bulbapedia](https://bulbapedia.bulbagarden.net/wiki/Status_condition) for greater detail.
     * Get move meta ailment
     */
    async moveAilmentRetrieveRaw(requestParameters: MoveAilmentRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MoveMetaAilmentDetail>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling moveAilmentRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/move-ailment/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MoveMetaAilmentDetailFromJSON(jsonValue));
    }

    /**
     * Move Ailments are status conditions caused by moves used during battle. See [Bulbapedia](https://bulbapedia.bulbagarden.net/wiki/Status_condition) for greater detail.
     * Get move meta ailment
     */
    async moveAilmentRetrieve(requestParameters: MoveAilmentRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MoveMetaAilmentDetail> {
        const response = await this.moveAilmentRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Styles of moves when used in the Battle Palace. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Battle_Frontier_(Generation_III)) for greater detail.
     * List move battle styles
     */
    async moveBattleStyleListRaw(requestParameters: MoveBattleStyleListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedMoveBattleStyleSummaryList>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/move-battle-style/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedMoveBattleStyleSummaryListFromJSON(jsonValue));
    }

    /**
     * Styles of moves when used in the Battle Palace. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Battle_Frontier_(Generation_III)) for greater detail.
     * List move battle styles
     */
    async moveBattleStyleList(requestParameters: MoveBattleStyleListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedMoveBattleStyleSummaryList> {
        const response = await this.moveBattleStyleListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Styles of moves when used in the Battle Palace. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Battle_Frontier_(Generation_III)) for greater detail.
     * Get move battle style
     */
    async moveBattleStyleRetrieveRaw(requestParameters: MoveBattleStyleRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MoveBattleStyleDetail>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling moveBattleStyleRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/move-battle-style/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MoveBattleStyleDetailFromJSON(jsonValue));
    }

    /**
     * Styles of moves when used in the Battle Palace. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Battle_Frontier_(Generation_III)) for greater detail.
     * Get move battle style
     */
    async moveBattleStyleRetrieve(requestParameters: MoveBattleStyleRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MoveBattleStyleDetail> {
        const response = await this.moveBattleStyleRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Very general categories that loosely group move effects.
     * List move meta categories
     */
    async moveCategoryListRaw(requestParameters: MoveCategoryListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedMoveMetaCategorySummaryList>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/move-category/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedMoveMetaCategorySummaryListFromJSON(jsonValue));
    }

    /**
     * Very general categories that loosely group move effects.
     * List move meta categories
     */
    async moveCategoryList(requestParameters: MoveCategoryListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedMoveMetaCategorySummaryList> {
        const response = await this.moveCategoryListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Very general categories that loosely group move effects.
     * Get move meta category
     */
    async moveCategoryRetrieveRaw(requestParameters: MoveCategoryRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MoveMetaCategoryDetail>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling moveCategoryRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/move-category/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MoveMetaCategoryDetailFromJSON(jsonValue));
    }

    /**
     * Very general categories that loosely group move effects.
     * Get move meta category
     */
    async moveCategoryRetrieve(requestParameters: MoveCategoryRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MoveMetaCategoryDetail> {
        const response = await this.moveCategoryRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Damage classes moves can have, e.g. physical, special, or non-damaging.
     * List move damage classes
     */
    async moveDamageClassListRaw(requestParameters: MoveDamageClassListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedMoveDamageClassSummaryList>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/move-damage-class/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedMoveDamageClassSummaryListFromJSON(jsonValue));
    }

    /**
     * Damage classes moves can have, e.g. physical, special, or non-damaging.
     * List move damage classes
     */
    async moveDamageClassList(requestParameters: MoveDamageClassListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedMoveDamageClassSummaryList> {
        const response = await this.moveDamageClassListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Damage classes moves can have, e.g. physical, special, or non-damaging.
     * Get move damage class
     */
    async moveDamageClassRetrieveRaw(requestParameters: MoveDamageClassRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MoveDamageClassDetail>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling moveDamageClassRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/move-damage-class/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MoveDamageClassDetailFromJSON(jsonValue));
    }

    /**
     * Damage classes moves can have, e.g. physical, special, or non-damaging.
     * Get move damage class
     */
    async moveDamageClassRetrieve(requestParameters: MoveDamageClassRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MoveDamageClassDetail> {
        const response = await this.moveDamageClassRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Methods by which Pokémon can learn moves.
     * List move learn methods
     */
    async moveLearnMethodListRaw(requestParameters: MoveLearnMethodListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedMoveLearnMethodSummaryList>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/move-learn-method/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedMoveLearnMethodSummaryListFromJSON(jsonValue));
    }

    /**
     * Methods by which Pokémon can learn moves.
     * List move learn methods
     */
    async moveLearnMethodList(requestParameters: MoveLearnMethodListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedMoveLearnMethodSummaryList> {
        const response = await this.moveLearnMethodListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Methods by which Pokémon can learn moves.
     * Get move learn method
     */
    async moveLearnMethodRetrieveRaw(requestParameters: MoveLearnMethodRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MoveLearnMethodDetail>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling moveLearnMethodRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/move-learn-method/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MoveLearnMethodDetailFromJSON(jsonValue));
    }

    /**
     * Methods by which Pokémon can learn moves.
     * Get move learn method
     */
    async moveLearnMethodRetrieve(requestParameters: MoveLearnMethodRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MoveLearnMethodDetail> {
        const response = await this.moveLearnMethodRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Moves are the skills of Pokémon in battle. In battle, a Pokémon uses one move each turn. Some moves (including those learned by Hidden Machine) can be used outside of battle as well, usually for the purpose of removing obstacles or exploring new areas.
     * List moves
     */
    async moveListRaw(requestParameters: MoveListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedMoveSummaryList>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/move/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedMoveSummaryListFromJSON(jsonValue));
    }

    /**
     * Moves are the skills of Pokémon in battle. In battle, a Pokémon uses one move each turn. Some moves (including those learned by Hidden Machine) can be used outside of battle as well, usually for the purpose of removing obstacles or exploring new areas.
     * List moves
     */
    async moveList(requestParameters: MoveListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedMoveSummaryList> {
        const response = await this.moveListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Moves are the skills of Pokémon in battle. In battle, a Pokémon uses one move each turn. Some moves (including those learned by Hidden Machine) can be used outside of battle as well, usually for the purpose of removing obstacles or exploring new areas.
     * Get move
     */
    async moveRetrieveRaw(requestParameters: MoveRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MoveDetail>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling moveRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/move/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MoveDetailFromJSON(jsonValue));
    }

    /**
     * Moves are the skills of Pokémon in battle. In battle, a Pokémon uses one move each turn. Some moves (including those learned by Hidden Machine) can be used outside of battle as well, usually for the purpose of removing obstacles or exploring new areas.
     * Get move
     */
    async moveRetrieve(requestParameters: MoveRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MoveDetail> {
        const response = await this.moveRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Targets moves can be directed at during battle. Targets can be Pokémon, environments or even other moves.
     * List move targets
     */
    async moveTargetListRaw(requestParameters: MoveTargetListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedMoveTargetSummaryList>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/move-target/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedMoveTargetSummaryListFromJSON(jsonValue));
    }

    /**
     * Targets moves can be directed at during battle. Targets can be Pokémon, environments or even other moves.
     * List move targets
     */
    async moveTargetList(requestParameters: MoveTargetListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedMoveTargetSummaryList> {
        const response = await this.moveTargetListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Targets moves can be directed at during battle. Targets can be Pokémon, environments or even other moves.
     * Get move target
     */
    async moveTargetRetrieveRaw(requestParameters: MoveTargetRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MoveTargetDetail>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling moveTargetRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/move-target/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MoveTargetDetailFromJSON(jsonValue));
    }

    /**
     * Targets moves can be directed at during battle. Targets can be Pokémon, environments or even other moves.
     * Get move target
     */
    async moveTargetRetrieve(requestParameters: MoveTargetRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MoveTargetDetail> {
        const response = await this.moveTargetRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Natures influence how a Pokémon\'s stats grow. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Nature) for greater detail.
     * List natures
     */
    async natureListRaw(requestParameters: NatureListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedNatureSummaryList>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/nature/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedNatureSummaryListFromJSON(jsonValue));
    }

    /**
     * Natures influence how a Pokémon\'s stats grow. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Nature) for greater detail.
     * List natures
     */
    async natureList(requestParameters: NatureListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedNatureSummaryList> {
        const response = await this.natureListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Natures influence how a Pokémon\'s stats grow. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Nature) for greater detail.
     * Get nature
     */
    async natureRetrieveRaw(requestParameters: NatureRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NatureDetail>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling natureRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/nature/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => NatureDetailFromJSON(jsonValue));
    }

    /**
     * Natures influence how a Pokémon\'s stats grow. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Nature) for greater detail.
     * Get nature
     */
    async natureRetrieve(requestParameters: NatureRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NatureDetail> {
        const response = await this.natureRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Areas used for grouping Pokémon encounters in Pal Park. They\'re like habitats that are specific to Pal Park.
     * List pal park areas
     */
    async palParkAreaListRaw(requestParameters: PalParkAreaListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedPalParkAreaSummaryList>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/pal-park-area/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedPalParkAreaSummaryListFromJSON(jsonValue));
    }

    /**
     * Areas used for grouping Pokémon encounters in Pal Park. They\'re like habitats that are specific to Pal Park.
     * List pal park areas
     */
    async palParkAreaList(requestParameters: PalParkAreaListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedPalParkAreaSummaryList> {
        const response = await this.palParkAreaListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Areas used for grouping Pokémon encounters in Pal Park. They\'re like habitats that are specific to Pal Park.
     * Get pal park area
     */
    async palParkAreaRetrieveRaw(requestParameters: PalParkAreaRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PalParkAreaDetail>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling palParkAreaRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/pal-park-area/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PalParkAreaDetailFromJSON(jsonValue));
    }

    /**
     * Areas used for grouping Pokémon encounters in Pal Park. They\'re like habitats that are specific to Pal Park.
     * Get pal park area
     */
    async palParkAreaRetrieve(requestParameters: PalParkAreaRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PalParkAreaDetail> {
        const response = await this.palParkAreaRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Pokeathlon Stats are different attributes of a Pokémon\'s performance in Pokéathlons. In Pokéathlons, competitions happen on different courses; one for each of the different Pokéathlon stats. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Pok%C3%A9athlon) for greater detail.
     * List pokeathlon stats
     */
    async pokeathlonStatListRaw(requestParameters: PokeathlonStatListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedPokeathlonStatSummaryList>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/pokeathlon-stat/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedPokeathlonStatSummaryListFromJSON(jsonValue));
    }

    /**
     * Pokeathlon Stats are different attributes of a Pokémon\'s performance in Pokéathlons. In Pokéathlons, competitions happen on different courses; one for each of the different Pokéathlon stats. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Pok%C3%A9athlon) for greater detail.
     * List pokeathlon stats
     */
    async pokeathlonStatList(requestParameters: PokeathlonStatListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedPokeathlonStatSummaryList> {
        const response = await this.pokeathlonStatListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Pokeathlon Stats are different attributes of a Pokémon\'s performance in Pokéathlons. In Pokéathlons, competitions happen on different courses; one for each of the different Pokéathlon stats. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Pok%C3%A9athlon) for greater detail.
     * Get pokeathlon stat
     */
    async pokeathlonStatRetrieveRaw(requestParameters: PokeathlonStatRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PokeathlonStatDetail>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling pokeathlonStatRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/pokeathlon-stat/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PokeathlonStatDetailFromJSON(jsonValue));
    }

    /**
     * Pokeathlon Stats are different attributes of a Pokémon\'s performance in Pokéathlons. In Pokéathlons, competitions happen on different courses; one for each of the different Pokéathlon stats. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Pok%C3%A9athlon) for greater detail.
     * Get pokeathlon stat
     */
    async pokeathlonStatRetrieve(requestParameters: PokeathlonStatRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PokeathlonStatDetail> {
        const response = await this.pokeathlonStatRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * A Pokédex is a handheld electronic encyclopedia device; one which is capable of recording and retaining information of the various Pokémon in a given region with the exception of the national dex and some smaller dexes related to portions of a region. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Pokedex) for greater detail.
     * List pokedex
     */
    async pokedexListRaw(requestParameters: PokedexListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedPokedexSummaryList>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/pokedex/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedPokedexSummaryListFromJSON(jsonValue));
    }

    /**
     * A Pokédex is a handheld electronic encyclopedia device; one which is capable of recording and retaining information of the various Pokémon in a given region with the exception of the national dex and some smaller dexes related to portions of a region. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Pokedex) for greater detail.
     * List pokedex
     */
    async pokedexList(requestParameters: PokedexListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedPokedexSummaryList> {
        const response = await this.pokedexListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * A Pokédex is a handheld electronic encyclopedia device; one which is capable of recording and retaining information of the various Pokémon in a given region with the exception of the national dex and some smaller dexes related to portions of a region. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Pokedex) for greater detail.
     * Get pokedex
     */
    async pokedexRetrieveRaw(requestParameters: PokedexRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PokedexDetail>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling pokedexRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/pokedex/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PokedexDetailFromJSON(jsonValue));
    }

    /**
     * A Pokédex is a handheld electronic encyclopedia device; one which is capable of recording and retaining information of the various Pokémon in a given region with the exception of the national dex and some smaller dexes related to portions of a region. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Pokedex) for greater detail.
     * Get pokedex
     */
    async pokedexRetrieve(requestParameters: PokedexRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PokedexDetail> {
        const response = await this.pokedexRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Colors used for sorting Pokémon in a Pokédex. The color listed in the Pokédex is usually the color most apparent or covering each Pokémon\'s body. No orange category exists; Pokémon that are primarily orange are listed as red or brown.
     * List pokemon colors
     */
    async pokemonColorListRaw(requestParameters: PokemonColorListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedPokemonColorSummaryList>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/pokemon-color/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedPokemonColorSummaryListFromJSON(jsonValue));
    }

    /**
     * Colors used for sorting Pokémon in a Pokédex. The color listed in the Pokédex is usually the color most apparent or covering each Pokémon\'s body. No orange category exists; Pokémon that are primarily orange are listed as red or brown.
     * List pokemon colors
     */
    async pokemonColorList(requestParameters: PokemonColorListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedPokemonColorSummaryList> {
        const response = await this.pokemonColorListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Colors used for sorting Pokémon in a Pokédex. The color listed in the Pokédex is usually the color most apparent or covering each Pokémon\'s body. No orange category exists; Pokémon that are primarily orange are listed as red or brown.
     * Get pokemon color
     */
    async pokemonColorRetrieveRaw(requestParameters: PokemonColorRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PokemonColorDetail>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling pokemonColorRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/pokemon-color/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PokemonColorDetailFromJSON(jsonValue));
    }

    /**
     * Colors used for sorting Pokémon in a Pokédex. The color listed in the Pokédex is usually the color most apparent or covering each Pokémon\'s body. No orange category exists; Pokémon that are primarily orange are listed as red or brown.
     * Get pokemon color
     */
    async pokemonColorRetrieve(requestParameters: PokemonColorRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PokemonColorDetail> {
        const response = await this.pokemonColorRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Handles Pokemon Encounters as a sub-resource.
     * Get pokemon encounter
     */
    async pokemonEncountersRetrieveRaw(requestParameters: PokemonEncountersRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<PokemonEncountersRetrieve200ResponseInner>>> {
        if (requestParameters['pokemonId'] == null) {
            throw new runtime.RequiredError(
                'pokemonId',
                'Required parameter "pokemonId" was null or undefined when calling pokemonEncountersRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/pokemon/{pokemon_id}/encounters`.replace(`{${"pokemon_id"}}`, encodeURIComponent(String(requestParameters['pokemonId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PokemonEncountersRetrieve200ResponseInnerFromJSON));
    }

    /**
     * Handles Pokemon Encounters as a sub-resource.
     * Get pokemon encounter
     */
    async pokemonEncountersRetrieve(requestParameters: PokemonEncountersRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<PokemonEncountersRetrieve200ResponseInner>> {
        const response = await this.pokemonEncountersRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Some Pokémon may appear in one of multiple, visually different forms. These differences are purely cosmetic. For variations within a Pokémon species, which do differ in more than just visuals, the \'Pokémon\' entity is used to represent such a variety.
     * List pokemon forms
     */
    async pokemonFormListRaw(requestParameters: PokemonFormListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedPokemonFormSummaryList>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/pokemon-form/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedPokemonFormSummaryListFromJSON(jsonValue));
    }

    /**
     * Some Pokémon may appear in one of multiple, visually different forms. These differences are purely cosmetic. For variations within a Pokémon species, which do differ in more than just visuals, the \'Pokémon\' entity is used to represent such a variety.
     * List pokemon forms
     */
    async pokemonFormList(requestParameters: PokemonFormListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedPokemonFormSummaryList> {
        const response = await this.pokemonFormListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Some Pokémon may appear in one of multiple, visually different forms. These differences are purely cosmetic. For variations within a Pokémon species, which do differ in more than just visuals, the \'Pokémon\' entity is used to represent such a variety.
     * Get pokemon form
     */
    async pokemonFormRetrieveRaw(requestParameters: PokemonFormRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PokemonFormDetail>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling pokemonFormRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/pokemon-form/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PokemonFormDetailFromJSON(jsonValue));
    }

    /**
     * Some Pokémon may appear in one of multiple, visually different forms. These differences are purely cosmetic. For variations within a Pokémon species, which do differ in more than just visuals, the \'Pokémon\' entity is used to represent such a variety.
     * Get pokemon form
     */
    async pokemonFormRetrieve(requestParameters: PokemonFormRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PokemonFormDetail> {
        const response = await this.pokemonFormRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Habitats are generally different terrain Pokémon can be found in but can also be areas designated for rare or legendary Pokémon.
     * List pokemom habitas
     */
    async pokemonHabitatListRaw(requestParameters: PokemonHabitatListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedPokemonHabitatSummaryList>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/pokemon-habitat/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedPokemonHabitatSummaryListFromJSON(jsonValue));
    }

    /**
     * Habitats are generally different terrain Pokémon can be found in but can also be areas designated for rare or legendary Pokémon.
     * List pokemom habitas
     */
    async pokemonHabitatList(requestParameters: PokemonHabitatListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedPokemonHabitatSummaryList> {
        const response = await this.pokemonHabitatListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Habitats are generally different terrain Pokémon can be found in but can also be areas designated for rare or legendary Pokémon.
     * Get pokemom habita
     */
    async pokemonHabitatRetrieveRaw(requestParameters: PokemonHabitatRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PokemonHabitatDetail>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling pokemonHabitatRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/pokemon-habitat/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PokemonHabitatDetailFromJSON(jsonValue));
    }

    /**
     * Habitats are generally different terrain Pokémon can be found in but can also be areas designated for rare or legendary Pokémon.
     * Get pokemom habita
     */
    async pokemonHabitatRetrieve(requestParameters: PokemonHabitatRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PokemonHabitatDetail> {
        const response = await this.pokemonHabitatRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Pokémon are the creatures that inhabit the world of the Pokémon games. They can be caught using Pokéballs and trained by battling with other Pokémon. Each Pokémon belongs to a specific species but may take on a variant which makes it differ from other Pokémon of the same species, such as base stats, available abilities and typings. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Pok%C3%A9mon_(species)) for greater detail.
     * List pokemon
     */
    async pokemonListRaw(requestParameters: PokemonListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedPokemonSummaryList>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/pokemon/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedPokemonSummaryListFromJSON(jsonValue));
    }

    /**
     * Pokémon are the creatures that inhabit the world of the Pokémon games. They can be caught using Pokéballs and trained by battling with other Pokémon. Each Pokémon belongs to a specific species but may take on a variant which makes it differ from other Pokémon of the same species, such as base stats, available abilities and typings. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Pok%C3%A9mon_(species)) for greater detail.
     * List pokemon
     */
    async pokemonList(requestParameters: PokemonListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedPokemonSummaryList> {
        const response = await this.pokemonListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Pokémon are the creatures that inhabit the world of the Pokémon games. They can be caught using Pokéballs and trained by battling with other Pokémon. Each Pokémon belongs to a specific species but may take on a variant which makes it differ from other Pokémon of the same species, such as base stats, available abilities and typings. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Pok%C3%A9mon_(species)) for greater detail.
     * Get pokemon
     */
    async pokemonRetrieveRaw(requestParameters: PokemonRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PokemonDetail>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling pokemonRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/pokemon/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PokemonDetailFromJSON(jsonValue));
    }

    /**
     * Pokémon are the creatures that inhabit the world of the Pokémon games. They can be caught using Pokéballs and trained by battling with other Pokémon. Each Pokémon belongs to a specific species but may take on a variant which makes it differ from other Pokémon of the same species, such as base stats, available abilities and typings. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Pok%C3%A9mon_(species)) for greater detail.
     * Get pokemon
     */
    async pokemonRetrieve(requestParameters: PokemonRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PokemonDetail> {
        const response = await this.pokemonRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Shapes used for sorting Pokémon in a Pokédex.
     * List pokemon shapes
     */
    async pokemonShapeListRaw(requestParameters: PokemonShapeListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedPokemonShapeSummaryList>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/pokemon-shape/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedPokemonShapeSummaryListFromJSON(jsonValue));
    }

    /**
     * Shapes used for sorting Pokémon in a Pokédex.
     * List pokemon shapes
     */
    async pokemonShapeList(requestParameters: PokemonShapeListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedPokemonShapeSummaryList> {
        const response = await this.pokemonShapeListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Shapes used for sorting Pokémon in a Pokédex.
     * Get pokemon shape
     */
    async pokemonShapeRetrieveRaw(requestParameters: PokemonShapeRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PokemonShapeDetail>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling pokemonShapeRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/pokemon-shape/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PokemonShapeDetailFromJSON(jsonValue));
    }

    /**
     * Shapes used for sorting Pokémon in a Pokédex.
     * Get pokemon shape
     */
    async pokemonShapeRetrieve(requestParameters: PokemonShapeRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PokemonShapeDetail> {
        const response = await this.pokemonShapeRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * A Pokémon Species forms the basis for at least one Pokémon. Attributes of a Pokémon species are shared across all varieties of Pokémon within the species. A good example is Wormadam; Wormadam is the species which can be found in three different varieties, Wormadam-Trash, Wormadam-Sandy and Wormadam-Plant.
     * List pokemon species
     */
    async pokemonSpeciesListRaw(requestParameters: PokemonSpeciesListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedPokemonSpeciesSummaryList>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/pokemon-species/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedPokemonSpeciesSummaryListFromJSON(jsonValue));
    }

    /**
     * A Pokémon Species forms the basis for at least one Pokémon. Attributes of a Pokémon species are shared across all varieties of Pokémon within the species. A good example is Wormadam; Wormadam is the species which can be found in three different varieties, Wormadam-Trash, Wormadam-Sandy and Wormadam-Plant.
     * List pokemon species
     */
    async pokemonSpeciesList(requestParameters: PokemonSpeciesListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedPokemonSpeciesSummaryList> {
        const response = await this.pokemonSpeciesListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * A Pokémon Species forms the basis for at least one Pokémon. Attributes of a Pokémon species are shared across all varieties of Pokémon within the species. A good example is Wormadam; Wormadam is the species which can be found in three different varieties, Wormadam-Trash, Wormadam-Sandy and Wormadam-Plant.
     * Get pokemon species
     */
    async pokemonSpeciesRetrieveRaw(requestParameters: PokemonSpeciesRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PokemonSpeciesDetail>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling pokemonSpeciesRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/pokemon-species/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PokemonSpeciesDetailFromJSON(jsonValue));
    }

    /**
     * A Pokémon Species forms the basis for at least one Pokémon. Attributes of a Pokémon species are shared across all varieties of Pokémon within the species. A good example is Wormadam; Wormadam is the species which can be found in three different varieties, Wormadam-Trash, Wormadam-Sandy and Wormadam-Plant.
     * Get pokemon species
     */
    async pokemonSpeciesRetrieve(requestParameters: PokemonSpeciesRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PokemonSpeciesDetail> {
        const response = await this.pokemonSpeciesRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * A region is an organized area of the Pokémon world. Most often, the main difference between regions is the species of Pokémon that can be encountered within them.
     * List regions
     */
    async regionListRaw(requestParameters: RegionListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedRegionSummaryList>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/region/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedRegionSummaryListFromJSON(jsonValue));
    }

    /**
     * A region is an organized area of the Pokémon world. Most often, the main difference between regions is the species of Pokémon that can be encountered within them.
     * List regions
     */
    async regionList(requestParameters: RegionListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedRegionSummaryList> {
        const response = await this.regionListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * A region is an organized area of the Pokémon world. Most often, the main difference between regions is the species of Pokémon that can be encountered within them.
     * Get region
     */
    async regionRetrieveRaw(requestParameters: RegionRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RegionDetail>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling regionRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/region/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RegionDetailFromJSON(jsonValue));
    }

    /**
     * A region is an organized area of the Pokémon world. Most often, the main difference between regions is the species of Pokémon that can be encountered within them.
     * Get region
     */
    async regionRetrieve(requestParameters: RegionRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RegionDetail> {
        const response = await this.regionRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Stats determine certain aspects of battles. Each Pokémon has a value for each stat which grows as they gain levels and can be altered momentarily by effects in battles.
     * List stats
     */
    async statListRaw(requestParameters: StatListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedStatSummaryList>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/stat/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedStatSummaryListFromJSON(jsonValue));
    }

    /**
     * Stats determine certain aspects of battles. Each Pokémon has a value for each stat which grows as they gain levels and can be altered momentarily by effects in battles.
     * List stats
     */
    async statList(requestParameters: StatListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedStatSummaryList> {
        const response = await this.statListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Stats determine certain aspects of battles. Each Pokémon has a value for each stat which grows as they gain levels and can be altered momentarily by effects in battles.
     * Get stat
     */
    async statRetrieveRaw(requestParameters: StatRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StatDetail>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling statRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/stat/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatDetailFromJSON(jsonValue));
    }

    /**
     * Stats determine certain aspects of battles. Each Pokémon has a value for each stat which grows as they gain levels and can be altered momentarily by effects in battles.
     * Get stat
     */
    async statRetrieve(requestParameters: StatRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StatDetail> {
        const response = await this.statRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Super contest effects refer to the effects of moves when used in super contests.
     * List super contest effects
     */
    async superContestEffectListRaw(requestParameters: SuperContestEffectListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedSuperContestEffectSummaryList>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/super-contest-effect/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedSuperContestEffectSummaryListFromJSON(jsonValue));
    }

    /**
     * Super contest effects refer to the effects of moves when used in super contests.
     * List super contest effects
     */
    async superContestEffectList(requestParameters: SuperContestEffectListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedSuperContestEffectSummaryList> {
        const response = await this.superContestEffectListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Super contest effects refer to the effects of moves when used in super contests.
     * Get super contest effect
     */
    async superContestEffectRetrieveRaw(requestParameters: SuperContestEffectRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuperContestEffectDetail>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling superContestEffectRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/super-contest-effect/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuperContestEffectDetailFromJSON(jsonValue));
    }

    /**
     * Super contest effects refer to the effects of moves when used in super contests.
     * Get super contest effect
     */
    async superContestEffectRetrieve(requestParameters: SuperContestEffectRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuperContestEffectDetail> {
        const response = await this.superContestEffectRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Types are properties for Pokémon and their moves. Each type has three properties: which types of Pokémon it is super effective against, which types of Pokémon it is not very effective against, and which types of Pokémon it is completely ineffective against.
     * List types
     */
    async typeListRaw(requestParameters: TypeListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedTypeSummaryList>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/type/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedTypeSummaryListFromJSON(jsonValue));
    }

    /**
     * Types are properties for Pokémon and their moves. Each type has three properties: which types of Pokémon it is super effective against, which types of Pokémon it is not very effective against, and which types of Pokémon it is completely ineffective against.
     * List types
     */
    async typeList(requestParameters: TypeListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedTypeSummaryList> {
        const response = await this.typeListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Types are properties for Pokémon and their moves. Each type has three properties: which types of Pokémon it is super effective against, which types of Pokémon it is not very effective against, and which types of Pokémon it is completely ineffective against.
     * Get types
     */
    async typeRetrieveRaw(requestParameters: TypeRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TypeDetail>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling typeRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/type/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TypeDetailFromJSON(jsonValue));
    }

    /**
     * Types are properties for Pokémon and their moves. Each type has three properties: which types of Pokémon it is super effective against, which types of Pokémon it is not very effective against, and which types of Pokémon it is completely ineffective against.
     * Get types
     */
    async typeRetrieve(requestParameters: TypeRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TypeDetail> {
        const response = await this.typeRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Version groups categorize highly similar versions of the games.
     * List version groups
     */
    async versionGroupListRaw(requestParameters: VersionGroupListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedVersionGroupSummaryList>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/version-group/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedVersionGroupSummaryListFromJSON(jsonValue));
    }

    /**
     * Version groups categorize highly similar versions of the games.
     * List version groups
     */
    async versionGroupList(requestParameters: VersionGroupListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedVersionGroupSummaryList> {
        const response = await this.versionGroupListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Version groups categorize highly similar versions of the games.
     * Get version group
     */
    async versionGroupRetrieveRaw(requestParameters: VersionGroupRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<VersionGroupDetail>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling versionGroupRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/version-group/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => VersionGroupDetailFromJSON(jsonValue));
    }

    /**
     * Version groups categorize highly similar versions of the games.
     * Get version group
     */
    async versionGroupRetrieve(requestParameters: VersionGroupRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<VersionGroupDetail> {
        const response = await this.versionGroupRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Versions of the games, e.g., Red, Blue or Yellow.
     * List versions
     */
    async versionListRaw(requestParameters: VersionListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedVersionSummaryList>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/version/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedVersionSummaryListFromJSON(jsonValue));
    }

    /**
     * Versions of the games, e.g., Red, Blue or Yellow.
     * List versions
     */
    async versionList(requestParameters: VersionListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedVersionSummaryList> {
        const response = await this.versionListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Versions of the games, e.g., Red, Blue or Yellow.
     * Get version
     */
    async versionRetrieveRaw(requestParameters: VersionRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<VersionDetail>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling versionRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/v2/version/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => VersionDetailFromJSON(jsonValue));
    }

    /**
     * Versions of the games, e.g., Red, Blue or Yellow.
     * Get version
     */
    async versionRetrieve(requestParameters: VersionRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<VersionDetail> {
        const response = await this.versionRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
